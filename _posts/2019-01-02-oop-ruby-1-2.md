---
layout: post
title:  "Ruby - Обектно-ориентированное проектирование (гл. 1, 2)"
---
### Глава 1
Если приложению в случае удачи уготована долгая жизнь, самой серьезной проблемой станет внесение изменений. Задача проектирования состоит в создании такой структуры кода, которая позволит эффективно приспосабливаться к изменениям.

### Глава 2
#### Группировка методов в классы
Несмотря на важность правильной группировки методов в классы, на ранней стадии разработки проекта вы не сможете все сделать правильно. Даже если ваше приложение успешно работает, многие решения, принятые сегодня, позже придется изменить. Когда наступит этот день, ваша возможность внесения этих изменений будет определяться конструкцией приложения.
Проектирование в большей степени является искусством сохранения возможности вносить изменения, чем способом достичь совершенства.

#### Организация кода для легкого внесения изменений
Легкость внесения изменений можно определить по следующим критериям:
- изменения не имеют неожиданных побочных эффектов;
- незначительные изменения в требованиях влекут за собой соответствующие незначительные изменения в коде;
- код легко поддается повторному использованию;
- самый простой способ внести изменения — добавить код, который сам по себе нетрудно изменить.

#### Почему именно единственная обязанность
Легко изменяемые приложения состоят из классов, которые легко поддаются повторному использованию. Повторно используемые классы представляют собой подключаемые элементы с четко определенным поведением, у которых мало переплетений.
Класс, имеющий несколько обязанностей, трудно поддается повторному использованию. При наличии сразу нескольких обязанностей высока вероятность их сильных переплетений внутри класса. Если потребуется повторно использовать некоторые из сторон его поведения (но не все), то невозможно получить только нужные части.

#### Определение наличия у класса единственной обязанности
Чем же класс фактически занимается, можно узнать, попытавшись описать его обязанности одним предложением. Класс обязан совершать хотя  бы одно полезное действие, которое должно поддаваться простому описанию. Если самое простое описание можно разделить с помощью союза «и», то у класса, скорее всего, несколько обязанностей. Если же используется слово «или», то у класса несколько обязанностей и у них могут быть весьма слабые связи.
Для описания данного понятия проектировщики объектно-ориентированных программных продуктов используют слово «сцепление» (cohesion). Если все, что есть в классе, имеет отношение к его главному предназначению, они говорят, что класс имеет сильное сцепление или что у него единственная обязанность.

#### Когда следует принимать проектировочные решения
Когда будущие потери от бездействия равны стоимости приложенных усилий сегодня, отложите решение. Принимайте его только тогда, когда поступившая к вам информация требует сделать это незамедлительно.

#### Скрытие переменных экземпляра
Вместо непосредственного обращения к переменным экземпляра их всегда следует заключать в метод доступа. Скрывайте переменные даже от того класса, в котором они определены, и заключайте их в методы.

#### Скрытие структур данных (Struct)
{% highlight ruby %}
class ObscuringReferences
  attr_reader :data
  def initialize(data)
    @data = data
  end
  
  def diameters
    # 0 - rim (обод), 1  — tire (шина)
    data.collect {|cell|
    cell[0] + (cell[1] * 2)}
  end
{% endhighlight %}

{% highlight ruby %}
class RevealingReferences
  attr_reader :wheels
  def initialize(data)
    @wheels = wheelify(data)
  end

  def diameters
    wheels.collect {|wheel|
    wheel.rim + (wheel.tire * 2)}
  end

  Wheel = Struct.new(:rim, :tire)
  
  def wheelify(data)
    data.collect {|cell|
    Wheel.new(cell[0], cell[1])}
  end
end
{% endhighlight %}

#### Выделение у методов лишних обязанностей
Методы, как и классы, должны иметь единственную обязанность. По тем же причинам. Наличие единственной обязанности облегчает внесение изменений и повторное использование.

#### И наконец реальное колесо
{% highlight ruby %}
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(chainring, cog, wheel=nil)
    @chainring = chainring
    @cog = cog
    @wheel = wheel
  end

  def ratio
    chainring / cog.to_f
  end

  def gear_inches
    ratio * wheel.diameter
  end
end

class Wheel
  attr_reader :rim, :tire
  def initialize(rim, tire)
    @rim = rim
    @tire = tire
  end

  def diameter
    rim + (tire * 2)
  end

  def circumference
    diameter * Math::PI
  end
end

@wheel = Wheel.new(26, 1.5)
puts @wheel.circumference
# -> 91.106186954104

puts Gear.new(52, 11, @wheel).gear_inches
# -> 137.090909090909

puts Gear.new(52, 11).ratio
# -> 4.72727272727273
{% endhighlight %}

У обоих классов — по одной обязанности. Код, конечно, неидеален, но уже хорош.
