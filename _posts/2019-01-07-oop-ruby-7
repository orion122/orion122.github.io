---
layout: post
title:  "Ruby - Обектно-ориентированное проектирование (гл. 7)"
---
### Глава 7. Разделение ролевого поведения с помощью модулей
#### Основные сведения о ролях
Некоторые задачи требуют совместного использования поведения несколькими
никак не связанными объектами. Это общее поведение не зависит от класса, это
роль, которую играет объект. Многие из ролей, необходимых приложению, вы-
явятся в ходе проектирования, но часто неожиданные роли обнаруживаются
в ходе написания кода.
Когда ранее ничем не связанные объекты начинают играть общую роль, они
входят во взаимоотношения с объектами, для которых они играют эту роль. Эти
взаимоотношения не настолько видны, как те, которые создаются требованиями
по линии родительского класса и подкласса при классическом наследовании.
Использование роли создает зависимости между вовлеченными в нее объекта-
ми, и эти зависимости привносят риски, которые следует брать в расчет, при-
нимая решение насчет вариантов проектирования.
В этом разделе выявляется скрытая роль и создается код для разделения
соответствующего ей поведения среди всех исполнителей (наряду с минимиза-
цией возникающих в результате этого зависимостей).

#### Поиск ролей
Когда роль требует совместно используемого поведения, вы сталкиваетесь с проблемой организации
совместно используемого кода. В идеале этот код должен определяться в одном
месте, но быть доступным для использования любым объектом, желающим
проявлять себя как неявный тип и играть роль.

Способ определения именованной группы методов, независимых от класса
и примешиваемых к любому объекту, имеется во многих объектно-ориентиро-
ванных языках. В Ruby такие примешиваемые методы, или миксины, называ-
ются модулями. Методы могут определяться в модуле, а затем модуль может
добавляться к любому объекту. Таким образом модули предоставляют велико-
лепный способ, позволяющий объектам различных классов играть общую роль,
используя единый набор кода.

Когда в объект включается модуль, определенные в нем методы становятся
доступными через автоматическое делегирование.

Когда вы начинаете помещать код в модули и добавлять модули к объектам,
вы расширяете набор сообщений, на которые этот объект в состоянии ответить, и вводите новую область сложности конструкции.

#### Нужно позволить объектам говорить самим за себя
Объекты должны быть самоуправляемыми и содержать свое собственное поведение. Если вас
интересует объект B, то не нужно вас принуждать к знанию особенностей
объекта A (если единственным, для чего он нужен, является выяснение особен-
ностей объекта B).

#### Написание конкретного кода

class Bicycle
attr_reader :schedule, :size, :chain, :tire_size

# Внедрение Schedule и предоставление значения по умолчанию
def initialize(args={})
@schedule = args[:schedule] || Schedule.new
# ...
end

# Возвращение true, если данный велосипед доступен
# в заданный интервал времени (теперь определенный классом Bicycle)
def schedulable?(start_date, end_date)
!scheduled?(start_date - lead_days, end_date)
end

# Возвращение ответа от schedule
def scheduled?(start_date, end_date)
schedule.scheduled?(self, start_date, end_date)
end

# Возвращение количества lead_days (дней на подготовку),
# прежде чем велосипед может быть включен в план.
def lead_days
1
end

# ...
end

require 'date'
starting = Date.parse("2015/09/04")
ending = Date.parse("2015/09/10")

b = Bicycle.new
b.schedulable?(starting, ending)
# Этот Bicycle
# в плане между 2015-09-03 и 2015-09-10 отсутствует
# => true


#### Извлечение абстракции

module Schedulable
attr_writer :schedule
def schedule
@schedule ||= ::Schedule.new
end

def schedulable?(start_date, end_date)
!scheduled?(start_date - lead_days, end_date)
end

def scheduled?(start_date, end_date)
schedule.scheduled?(self, start_date, end_date)
end

# те, кто будет включать этот модуль, могут это переопределить
def lead_days
0
end
end

class Bicycle
include Schedulable

def lead_days
1
end

# ...
end

Создание этого модуля дало возможность другим объектам воспользо-
ваться им, чтобы они сами стали пригодными для включения в план. Они могут
играть эту роль без дублирования кода.

#### Выявление антишаблонов
...


