---
layout: post
title:  "Ruby - Обектно-ориентированное проектирование (гл. 4)"
---
###Глава 4
####Основные сведения об интерфейсах
выставляемые напоказ методы образуют открытый интерфейс класса. Слово интерфейс может иметь отношение к нескольким различным понятиям. В данном случае этот термин используется для той разновидности интерфейса, которая является классом. В классах реализуются методы, предназначенные для использования другими классами, именно такие методы и составляют открытый интерфейс класса.
К альтернативной разновидности интерфейса относится тот, который распространяется на несколько классов, в силу чего обладает независимостью от любого отдельно взятого класса. Используемое в этом смысле слово «интерфейс» олицетворяет набор сообщений (сами сообщения и определяют интерфейс).
Методы, требуемые интерфейсу, могут как часть целого быть реализованы во многих различных классах. Это почти то же самое, как если бы интерфейсом определялся виртуальный класс; то есть любой класс, реализующий требуемые методы, может действовать как своеобразный интерфейс.

####Открытые интерфейсы
Методы, составляющие открытый интерфейс класса, можно назвать внешними.
Они:
- показывают его главную обязанность;
- ожидают вызова из других объектов;
- не изменяются ни с того ни с сего;
- безопасны для других объектов, зависящих от них;
- тщательно задокументированы в тестах.

####Закрытые интерфейсы
Все остальные методы в классе являются частью закрытого интерфейса. Они:
- занимаются реализацией особенностей класса;
- не ожидают отправления другим объектам;
- могут изменяться по какой-либо причине;
- в случае зависимости от них не гарантируют никакой безопасности;
- могут даже не упоминаться в тестах.

####Обязанности, зависимости и интерфейсы
Открытые части класса относятся к стабильным частям, а закрытые — к изменяемым. Когда методы помечаются как открытые или закрытые, вы сообщаете пользователям вашего класса, от каких методов они могут безопасно зависеть. Когда ваши классы используют открытые методы других классов, вы верите в то, что эти методы будут стабильными. Когда вы принимаете решение попасть в зависимость от закрытых методов других классов, вы должны отдавать себе отчет, что полагаетесь на заведомо нестабильные вещи, повышая тем самым риск подверженности воздействию отдаленного и не связанного с вашими задачами изменения.

####Формирование намерения
Идея создания этих классов пришла в голову, потому что они представляют собой существительные в приложении, имеющем как данные, так и поведение. Назовите их объектами предметной области. Их очевидность обусловлена постоянным присутствием, они обозначают крупные, вполне ощутимые в реальном мире вещи, которые в конечном итоге превращаются в представления в вашей базе данных.

Объекты предметной области легко поддаются обнаружению, но они не явля­ются центром проектирования вашего приложения. Это ловушка для опрометчивых людей. Если зацикливаться на объектах предметной области, возникнет желание задать им определенное поведение. Опытные проектировщики замечают объекты предметной области, не концентрируясь на них, их внимание сосредотачивается не на них, а на сообщениях, которые проходят между ними. Эти сообщения являются ориентирами, ведущими к открытию других объектов, которые также необходимы, но имеют гораздо меньшую степень очевидности.

####Нужно не говорить «как», а спрашивать «что»
![ruby-oop-4.5]({{ "/assets/ruby-oop-4.5.png" }})
Когда разговор между Trip и  Mechanic перешел с «как» на «что», один из сопутствующих эффектов выразился в том, что размер внешнего интерфейса класса Mechanic резко уменьшился. На рис. 4.5 Mechanic открывает доступ ко многим методам, а на рис. 4.6 его открытый интерфейс состоит из одного метода по имени prepare_bicycle . Поскольку Mechanic обещает, что его открытый интерфейс будет стабилен и неизменен, наличие небольшого открытого интерфейса означает, что другие теперь зависят от малого количества методов. Это снижает вероятность того, что однажды открытый интерфейс класса Mechanic изменится, нарушив его обещания и заставив внести изменения во многие другие классы. Это изменение схемы сообщений является существенным улучшением с точки зрения возможности сопровождения кода, но класс Trip по-прежнему знает многое о классе Mechanic . Код станет гибче и легче в сопровождении, если класс Trip сможет выполнить свои задачи при еще меньшем объеме знаний.
![ruby-oop-4.6]({{ "/assets/ruby-oop-4.6.png" }})

####Поиск контекста независимости
То, что Trip знает о других объектах, составляет его контекст. Это нужно представлять таким образом: у  Trip есть единственная обязанность, но этот класс ожидает контекст. На рис. 4.6 класс Trip возлагает свои надежды на объект типа Mechanic , способный ответить на сообщение prepare_bicycle. Контекст является верхней одеждой, которую Trip носит повсюду; любое использование Trip , будь то тестирование или что-либо иное, требует, чтобы был образован его контекст. Подготовка путешествия, представляемого классом Trip, всегда требует подготовки велосипедов и происходит таким образом, что Trip всегда отправляет классу Mechanic сообщение prepare_bicycle . Вы не можете использовать Trip где-либо еще, если не предоставите объект, похожий на объект класса Mechanic , который ответит на это сообщение. Ожидаемый объектом контекст напрямую влияет на степень трудности его повторного использования. Объекты, имеющие простой контекст, проще применять и легче тестировать, и у них весьма скромные ожидания, связанные с окружением. Объекты со сложным контекстом трудно использовать и нелегко тестировать, и для получения от них какой-нибудь пользы требуются сложные настройки. Лучше всего было бы, чтобы объект вообще не зависел от своего контекста. Объект, способный сотрудничать с другими объектами, не зная, кто они такие или что они делают, может повторно использоваться новыми и порой самыми неожиданными способами. Вам уже известна технология сотрудничества с другими без знания о том, кто они такие, — это внедрение зависимости. Теперь у  Trip будет новая задача — побудить класс Mechanic к правильному поведению, не зная о том, чем он занимается. Классу Trip нужно сотрудничать с классом Mechanic , сохраняя независимость от контекста. На первый взгляд это кажется невозможным. Путешествие предполагает наличие велосипедов, которые должны быть подготовлены, а их подготовкой занимаются механики. Поэтому просьба Trip в адрес Mechanic подготовить Bicycle неизбежна. Но это не так. Решение задачи заключается в различии между «что» и «как», нахождение решения требует концентрации на том, что хочет Trip. То, что хочет Trip , заключается в готовности к путешествию. Знание о том, что нужно подготовить, входит в обязанности Trip . Но факт наличия велосипедов в готовом состоянии может быть в компетенции класса Mechanic. Необходимость подготовки велосипедов больше относится к тому, как готовится Trip , а не к тому, что Trip нужно.
![ruby-oop-4.7]({{ "/assets/ruby-oop-4.7.png" }})
На рис. 4.7 показан третий вариант диаграммы последовательности для подготовки Trip . Здесь Trip просто сообщает Mechanic о том, что ему нужно, то есть что ему нужно быть в готовности, и передает в качестве аргумента самого себя.
На диаграмме последовательности Trip ничего не знает о  Mechanic , но попрежнему управляет сотрудничеством с ним для получения готовых к эксплуа­тации велосипедов. Trip сообщает Mechanic о том, что ему нужно, передавая в качестве аргумента самого себя, и  Mechanic тут же совершает обратный вызов в адрес Trip , чтобы получить список тех велосипедов, которые нужно подготовить.
Все знания о том, как механики подготавливают путешествие, теперь изолированы внутри Mechanic , и контекст Trip сократился. Теперь оба объекта легче поддаются изменениям, тестированию и повторному использованию. 

####Доверие, оказываемое другим объектам
Если бы объекты были людьми и могли описать их взаимоотношения, то на рис. 4.5 Trip сказал бы Mechanic : «Я знаю, что мне нужно, и я знаю, как это сделать», на рис. 4.6 было бы сказано следующее: «Я знаю, что мне нужно, и я знаю, чем ты занимаешься», а на рис. 4.7: «Я знаю, что мне нужно, и я доверяю тебе выполнение твоей части работы». Такое слепое доверие является краеугольным камнем объектно-ориентированного проектирования. Оно позволяет объектам сотрудничать, не привязывая их самих к контексту; это необходимо обеспечить в любом приложении, для которого рассматриваются возможности его разрастания и изменения.

####Сообщения для обнаружения потребности в новых объектах
Вполне логично, что Customer нужно отправлять сообщение suitable_trips. Это сообщение повторяется в обеих диаграммах, поскольку оно представляется правильным по определению самой сути этого класса. Это именно то, что Customer хочет получить. Проблема не с отправителем, а с получателем. Вы еще не определили объект, в чьи обязанности будет входить реализация этого метода.
Это приложение нуждается в объекте, воплощающем в себе правила на пересечении Customer , Trip и  Bicycle . Метод suitable_trips будет частью именно его открытого интерфейса. Вам следует понять, что нужен еще не определенный объект, на котором заканчивается множество маршрутов. Преимущество, получаемое от обнаружения необходимости в пока еще отсутствующем объекте при составлении диаграммы последовательности, заключается в том, что ошибки обходятся весьма недорого, а препятствий для того, чтобы изменить свое мнение, нет практически никаких. Диаграммы последовательности составляются в экспериментальных целях и со временем утрачивают свое значение, их особенностью является то, что вы к ним никак не привязаны. Они не демонстрируют вашу конструкцию в ее конечном виде, но зато в них отображается замысел, являющийся стартовой позицией для проектирования.
Возможно, в приложении должен быть класс для поиска путешествий — TripFinder. На рис. 4.8 показана диаграмма последовательности, где классу TripFinder вменено в обязанность подыскивать подходящие путешествия. TripFinder содержит все сведения о том, что именно делает путешествие подходящим. Его работа заключается в том, чтобы делать все необходимое для ответа на соответствующее сообщение. Он предоставляет соответствующий открытый интерфейс и в то же время скрывает запутанные и склонные к изменениям внутренние детали. Перемещение этого метода в  TripFinder делает поведение доступным любому другому объекту. Возможно, в будущем классом TripFinder воспользуются другие туристические компании, чтобы подобрать подходящие путешествия через веб-сервис. Теперь, когда это поведение было изъято из Customer, он может изолированно использоваться любым другим объектом.
![ruby-oop-4.8]({{ "/assets/ruby-oop-4.8.png" }})
####Написание кода с отличным интерфейсом
Тщательно продумывайте свои интерфейсы. Создавайте их с вполне конкретными намерениями. Ваше приложение и определение его будущего зависят больше от интерфейсов, чем от всех тестов и любого другого вашего кода.

####Создавайте четко выраженные интерфейсы
Методы в открытом интерфейсе должны:
- быть явно идентифицированными;
- больше иметь отношение к тому, «что», чем к тому, «как именно»;
- обладать именами, которые (насколько это возможно предвидеть) не претерпят изменений;
- получать в качестве дополнительного параметра хеш.
Применяйте такие же намерения и для создания закрытого интерфейса, делайте его как можно более понятным.

####Закон Деметры
####Определение закона
Закон Деметры ограничивает набор объектов, которым метод может отправлять сообщения, и запрещает перенаправление сообщения третьему объекту через второй объект другого типа. Закон Деметры часто трактуют как «ведение разговора только с ближайшими соседями» или «использование в синтаксисе только одного символа точки».

####Как обойтись без нарушений
Одним из устоявшихся способов избавления от «крушения поезда» в коде программы является использование делегирования с целью отказа от точек. Чтобы в объектно-ориентированном понимании делегировать сообщение, его нужно передать в другой объект, зачастую применяя для этого метод-оболочку. Этот метод инкапсулирует или скрывает знания, которые в  противном случае были бы воплощены в цепочке сообщений.
Осуществить делегирование можно несколькими способами. В Ruby есть библиотеки delegate.rb и  forwardable.rb , а в среду Ruby on Rails включен метод delegate . Каждый из них предназначен для упрощения автоматического перехвата объектом сообщения, посланного ему самому вместо того, чтобы отправить его кому-нибудь еще. Делегирование выглядит отличным решением проблем с законом Деметры, поскольку устраняет видимые свидетельства его нарушений.

####Прислушиваясь к закону Деметры
Проблемы при нарушении закона Деметры сообщают о наличии объектов с недостаточно развитыми открытыми интерфейсами. Если вы предпочитаете обзор перспектив на основе сообщений, то выявленные сообщения превратятся в открытые интерфейсы в новых объектах, необходимость в которых обнаружится благодаря этим сообщениям. Но если вы «повязаны» уже существующими объектами конкретной предметной области, придется собирать имеющиеся у них открытые интерфейсы в длинные цепочки сообщений, упуская возможность поиска и построения гибких открытых интерфейсов.
