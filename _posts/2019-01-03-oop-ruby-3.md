---
layout: post
title:  "Ruby - Обектно-ориентированное проектирование (гл. 3)"
---
###Глава 3
####Основные сведения о зависимостях
{% highlight ruby %}
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end
  
  def gear_inches
    ratio * Wheel.new(rim, tire).diameter
  end
  
  def ratio
    chainring / cog.to_f
  end
# ...
end

class Wheel
  attr_reader :rim, :tire
  
  def initialize(rim, tire)
    @rim = rim
    @tire = tire
  end

  def diameter
    rim + (tire * 2)
  end
# ...
end

Gear.new(52, 11, 26, 1.5).gear_inches
{% endhighlight %}

####Выявление зависимостей
У объекта есть зависимость, когда он знает:
- имя другого класса. В классе Gear ожидается наличие класса по имени Wheel ;
- имя сообщения, которое намеревается отправить еще кому-то, кроме себя. Gear ожидает, что экземпляр Wheel откликнется на diameter ;
- аргументы, требуемые сообщению. Gear знает, что Wheel.new требует rim и  tire ;
- порядок следования этих аргументов. Gear знает, что первым аргументом Wheel.new должен быть rim , а вторым — tire.
Каждая из этих зависимостей предполагает, что Gear придется изменять в случае изменения Wheel.

####Внедренные зависимости
Основную точку привязанности создает ссылка на другой класс по его имени. В методе gear_inches содержится явная ссылка на класс Wheel (предыдущий код).
Вполне очевидным последствием этой ссылки является то, что при изменении имени класса Wheel должен измениться и метод gear_inches класса Gear.

Но есть более серьезная (и менее заметная) проблема, имеющая разрушительный характер.
Когда ссылка на Wheel в классе Gear жестко прописана глубоко внутри его метода gear_inches , она явным образом объявляет, что нужно лишь вычислить передаточное отношение в дюймах (gear inches) для экземпляров Wheel. Класс Gear отказывается от сотрудничества с любыми другими видами объекта, даже если у объекта есть диаметр и в нем используются передаточные механизмы.
Если ваше приложение расширяется с целью включения таких объектов, как диски или цилиндры, и вам требуется знать передаточное отношение в дюймах при их использовании, то вы этого сделать не можете. Независимо от факта наличия у дисков и цилиндров диаметра вы никогда не сможете вычислить их передаточное отношение в дюймах, поскольку класс Gear прикреплен к классу Wheel.
Приведенный выше код выставляет напоказ ничем не оправданное вложение в статичные типы. Важен не класс объекта, а сообщение, которое планируется ему отправить. Классу Gear нужен доступ к объекту, который может реагировать на сообщение diameter; если хотите, неявная типизация (см. главу 5). Классу Gear все равно, к какому классу принадлежит объект, и он не должен этого знать.
Классу Gear не обязательно знать о существовании класса Wheel, чтобы вычислить gear_inches . Он не должен знать, что Wheel ожидает инициализации сначала с использованием rim, а затем с использованием tire; ему нужен лишь объект, знающий diameter.

Вместо того чтобы быть приклеенной к  Wheel , следующая версия Gear ожидает инициализации с помощью объекта, способного откликнуться на diameter:
{% highlight ruby %}
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(chainring, cog, wheel)
    @chainring = chainring
    @cog = cog
  @wheel = wheel
  end

  def gear_inches
    ratio * wheel.diameter
  end
# ...
end
# Gear нужна «утка», знающая diameter
Gear.new(52, 11, Wheel.new(26, 1.5)).gear_inches
{% endhighlight %}

Вывод создания нового экземпляра Wheel за пределы класса Gear устраняет связь между двумя классами. Gear теперь может сотрудничать с любым объектом, в котором реализуется diameter. Данная технология известна как внедрение зависимости.

####Изоляция зависимостей
Если вы не можете удалить ненужные зависимости, их придется изолировать внутри класса.

####Изоляция при создании экземпляра
Если накладываются ограничения, не позволяющие изменить код с целью внед­ рения Wheel в  Gear, вам нужно изолировать создание нового экземпляра Wheel внутри класса Gear . Ваша задача — явно обозначить зависимость и при этом снизить степень ее вмешательства в ваш класс.
{% highlight ruby %}
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @wheel = Wheel.new(rim, tire)
  end

  def gear_inches
    ratio * wheel.diameter
  end
# ...
{% endhighlight %}
ИЛИ
{% highlight ruby %}
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def gear_inches
    ratio * wheel.diameter
  end

  def wheel
    @wheel ||= Wheel.new(rim, tire)
  end
# ...
{% endhighlight %}
И в том и в другом примере Gear все еще слишком осведомлен о многом. Но появилось и улучшение. Такие стили программирования сокращают количество зависимостей в  gear_inches и наряду с этим выставляют на всеобщее обозрение зависимость Gear от Wheel. Они показывают зависимости вместо того, чтобы скрывать их, облегчая повторное использование и упрощая реорганизацию кода при стечении благоприятных для этого обстоятельств. Такое изменение делает код гибче, и его будет проще приспособить под неизвестное пока будущее.

####Устранение зависимостей от порядка следования аргументов
{% highlight ruby %}
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(args)
    @chainring = args[:chainring]
    @cog = args[:cog]
    @wheel = args[:wheel]
  end
...
end

Gear.new(
  :chainring => 52,
  :cog => 11,
  :wheel => Wheel.new(26, 1.5)).gear_inches

####Явное определение значений по умолчанию
{% highlight ruby %}
# указание значений по умолчанию с помощью fetch
def initialize(args)
  @chainring = args.fetch(:chainring, 40)
  @cog = args.fetch(:cog, 18)
  @wheel = args[:wheel]
end
{% endhighlight %}

####Изоляция инициализации, при которой используются множественные параметры
{% highlight ruby %}
# Тот самый случай, когда Gear является частью внешнего интерфейса
module SomeFramework
  class Gear
    attr_reader :chainring, :cog, :wheel
    def initialize(chainring, cog, wheel)
      @chainring = chainring
      @cog = cog
      @wheel = wheel
    end
    # ...
  end
end
# заключение интерфейса в оболочку для вашей защиты от изменений
module GearWrapper
  def self.gear(args)
    SomeFramework::Gear.new(
      args[:chainring],
      args[:cog],
      args[:wheel])
    end
end
# Теперь новый экземпляр Gear можно создавать, используя хеш аргументов
GearWrapper.gear(
  :chainring => 52,
  :cog => 11,
  :wheel => Wheel.new(26, 1.5)).gear_inches
{% endhighlight %}

Еще одна интересная особенность GearWrapper  — то, что его единственной целью является создание экземпляров некоего другого класса. Для подобных объектов у проектировщиков объектно-ориентированных решений есть особое слово, они называют их фабриками (factories).

####Разворот в обратном направлении
{% highlight ruby %}
class Gear
  attr_reader :chainring, :cog
  def initialize(chainring, cog)
    @chainring = chainring
    @cog = cog
  end

  def gear_inches(diameter)
    ratio * diameter
  end

  def ratio
    chainring / cog.to_f
  end
  # ...
end

class Wheel
  attr_reader :rim, :tire, :gear
  def initialize(rim, tire, chainring, cog)
    @rim = rim
    @tire = tire
    @gear = Gear.new(chainring, cog)
  end

  def diameter
    rim + (tire * 2)
  end

  def gear_inches
    gear.gear_inches(diameter)
  end
  # ...
end

Wheel.new(26, 1.5, 52, 11).gear_inches
{% endhighlight %}

####Выбор направления
Представьте, что ваши классы — это люди. Если бы вам пришлось посоветовать им, как себя вести, то вы бы сказали: нужно действовать в зависимости от того, что меняется реже вас.
Это краткое утверждение противоречит идее, основанной на трех простых истинах, касающихся программного кода:
- некоторые классы более других подвержены изменениям своих требований;
- конкретные классы имеют более высокую вероятность изменений, чем абстрактные классы;
- внесение изменения в класс, имеющий множество зависимостей, повлечет за собой широкое распространение последствий.

####Определение конкретности и абстрактности
В Ruby, когда вы внедряете Wheel в  Gear таким образом, что потом Gear зависит от той самой «утки», отвечающей за diameter , вы (хотя и непреднамеренно) определяете интерфейс. Этот интерфейс является абстракцией идеи о том, что у определенной категории вещей будет иметься диаметр. Абстракция была получена из конкретного класса, и теперь идея характеризуется «отсутствием чего-либо общего с любым конкретным экземпляром».
Самое замечательное свойство абстракций заключается в том, что они представляют собой общие стабильные качества. Их изменение менее вероятно, чем изменение конкретных классов, из которых они были выведены. Зависимости от абстракции всегда безопаснее, чем зависимость от конкретики, поскольку по своей природе абстракции более стабильны.
